class Guides::Database::Querying < GuideAction
  guide_route "/database/querying"

  def self.title
    "Querying the Database"
  end

  def markdown
    <<-MD
    ## Query Objects

    When you [generate a model](#{Guides::Database::Models.path(anchor: Guides::Database::Models::ANCHOR_GENERATE_A_MODEL)}),
    Avram will create a Query class for you in `./src/queries/{model_name}_query.cr`.
    This class will inherit from `{ModelName}::BaseQuery`. (e.g. with a `User` model you get
    a `User::BaseQuery` class).

    ```crystal
    # src/queries/user_query.cr
    class UserQuery < User::BaseQuery
    end
    ```

    Each column defined on the model will also generate methods for the query object to use.
    This gives us a type-safe way to query on each column. All of the query methods are chainable
    for both simple and more complex queries.

    ## Running Queries

    When you run any query, you'll get back an instance of the model, array of that model instance,
    nil, or raise an exception (e.g. `Avram::RecordNotFoundError`).

    For our examples, we will use this `User` model.

    ```crystal
    class User < BaseModel
      table :users do
        # `id`, `created_at`, `updated_at` predefined for us
        column name : String
        column age : Int32
        column admin : Bool
      end
    end
    ```

    ### Simple helper methods

    By default, all query objects include `Enumerable(T)` methods like `each`, and `map`.
    There's also a few class methods for doing quick finds.

    * `first` - Returns the first record. Raise `Avram::RecordNotFoundError` if no record is found.
    * `first?` - Returns the first record. Returns `nil` if no record is found.
    * `find(id)` - Returns the record with the primary key `id`. Raise `Avram::RecordNotFoundError` if no record is found.
    * `last` - Returns the last record. Raise `Avram::RecordNotFoundError` if no record is found.
    * `last?` - Returns the last record. Returns `nil` if no record is found.
    * `all` - Returns an array of all the records.

    ## Simple Selects

    > When doing a `SELECT`, Avram will select all of the columns individually (i.e. `users.id,
    > users.created_at, users.updated_at, users.name, users.age, users.admin`) as opposed to `*`.
    > However, for brevity, we will use `COLUMNS`.

    ### Select all

    `SELECT COLUMNS FROM users`

    ```crystal
    users = UserQuery.all
    ```

    ### Select one

    Selecting the first user `SELECT COLUMNS FROM users LIMIT 1`

    ```crystal
    user = UserQuery.first
    ```

    Selecting the last user `SELECT COLUMNS FROM users ORDER BY users.id DESC LIMIT 1`

    ```crystal
    user = UserQuery.last
    ```

    Selecting the user with `id = 3` `SELECT COLUMNS FROM users WHERE id = 3 LIMIT 1`

    ```crystal
    user = UserQuery.find(3)
    ```

    ### Select distinct / distinct on

    `SELECT DISTINCT COLUMNS FROM users`

    ```crystal
    UserQuery.new.distinct
    ```

    Select distinct rows based on the `name` column `SELECT DISTINCT ON (users.name) FROM users`

    ```crystal
    UserQuery.new.distinct_on(&.name)
    ```

    > Notice these two methods are called in the instance of `UserQuery`, and not the class.
    > Aside from the quick select helper methods, the rest are instance methods.

    ## Where Queries

    The `WHERE` clauses are the most common used in SQL. Each of the columns generated by the model
    will give you a method for running a `WHERE` on that column. (e.g. the `age` column gives us `WHERE age = value` with the `age(value)` method.

    ### A = B

    `SELECT COLUMNS FROM users WHERE age = 54`

    ```crystal
    UserQuery.new.age(54)
    ```

    ### A = B AND C = D

    `SELECT COLUMNS FROM users WHERE age = 43 AND admin = true`

    ```crystal
    UserQuery.new.age(43).admin(true)
    ```

    > All query methods are chainable!

    ### A != B

    `SELECT COLUMNS FROM users WHERE name != 'Billy'`

    ```crystal
    UserQuery.new.name.not.eq("Billy")
    ```

    > The `not` method can be used to negate other methods like `eq`, `gt`, `lt`, `in`.

    ### A gt/lt B

    `WHERE age >= 21`

    ```crystal
    UserQuery.new.age.gte(21)
    ```

    `WHERE age > 59`

    ```crystal
    UserQuery.new.age.gt(59)
    ```

    `WHERE age <= 12`

    ```crystal
    UserQuery.new.age.lte(12)
    ```

    `WHERE age < 100`

    ```crystal
    UserQuery.new.age.lt(100)
    ```

    ### A in / not in (B)

    `WHERE name IN ('Bill', 'John')`

    ```crystal
    UserQuery.new.name.in(["Bill", "John"])
    ```

    `WHERE name NOT IN ('Sally', 'Jenny')`

    ```crystal
    UserQuery.new.name.not.in(["Sally", "Jenny"])
    ```

    ### A like / iLike B

    `WHERE name LIKE 'John%'`

    ```crystal
    UserQuery.new.name.like("John%")
    ```

    `WHERE name ILIKE 'jim'`

    ```crystal
    UserQuery.new.name.ilike("jim")
    ```

    ### Custom WHERE

    Avram also has a `where` method that gives you the ability to do custom and/or programmatic queries.

    `WHERE name = 'Dan' AND created_at > '#{3.days.ago}' AND created_at < '#{1.hour.ago}'`

    ```crystal
    UserQuery.new
      .where(:name, "Dan")
      .where("created_at > '?' AND created_at < '?'", 3.days.ago, 1.hour.ago)
    ```

    ## Ordering

    ## Pagination

    ### Limit

    ### Offset

    ## Aggregates

    ### Count

    `SELECT COUNT(*) FROM users`

    ```crystal
    total_count = UserQuery.new.select_count
    ```

    ### Avg / Sum

    ## Associations and Joins

    ### Joins

    ## Preloading

    ### without preloading

    ## No results

    ## Named Scopes

    ## Deleting Records

    ## Complex Queries

    If you need more complex queries that Lucky may not support, you can run [raw SQL](#{Guides::Database::RawSql.path})
    MD
  end
end
