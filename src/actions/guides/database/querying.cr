class Guides::Database::Querying < GuideAction
  guide_route "/database/querying"

  def self.title
    "Querying the Database"
  end

  def markdown
    <<-MD
    ## Querying the database

    When you define a model, Lucky creates a query class that you can use to get
    users from the database. The class is always called `{ModelName}::BaseQuery` .

    To use it, let's create a query object that inherits from the one generated by
    Lucky.

    ```crystal
    # src/queries/user_query.cr
    class UserQuery < User::BaseQuery
    end
    ```

    `User::BaseQuery` has methods for querying and retrieving users such as:

    * `first` - will raise if a record is not found
    * `first?` - for when you want to allow `nil` to be returned
    * `find`
    * All methods included by `Enumerable(T)`, such as `each` and `map`

    It also has methods for ordering and adding where clauses. These are generated
    based on the columns defined in your model.

    For the model we defined Lucky would generate:

    * `created_at` (automatically added)
    * `updated_at` (automatically added)
    * `id` (automatically added)
    * `age`
    * `name`


    ## Distinct on

    ```crystal
    UserQuery.new.distinct_on(&.name)
    ```

    ## Where clauses

    You can use the methods generated by Lucky to create where clauses.

    ```crystal
    # SELECT * FROM users where name='Paul';
    UserQuery.new.name("Paul")

    # SELECT * FROM users where age=28;
    UserQuery.new.age(28)
    ```

    ### Parsing query params

    Lucky will accept the type defined in the model (e.g. `Int32` for `age`) or a
    `String`. If you pass it a `String` then Lucky will attempt to parse it and use
    the type defined for the column.

    For example:

    ```crystal
    # Lucky parses the string and use an Int32 in the query
    UserQuery.new.age("30")

    # Won't accept other types
    # Fails at compile time because you can't pass a Float64
    UserQuery.new.age(30.0)
    ```

    > Note that this will change in the future but this is the current behavior. In
    the future only the defined type (`Int32` in this example) will work. You will
    then need to manually parse it. Don't worry though, Lucky will add some helpers
    to actions and the model to make this easy and maintainable.

    ## Ordering results

    ````crystal
    UserQuery.new.age.desc_order
    # or
    UserQuery.new.age.asc_order
    ````

    ## Chaining methods

    You can chain where clauses and most other query methods.

    ```crystal
    UserQuery.new.age.gt(28).age.desc_order
    ```

    ## Running the query

    The query does not actually hit the database until a method is called to fetch a
    result or iterate over results.

    Some of the most common methods are:

    * `first`
    * `find`
    * `each`

    For example:

    ```crystal
    # The query is not yet run
    query = UserQuery.new
    query.name("Sally")
    query.age(30)

    # The query will run once `each` is called
    # Results are not cached so a request will be made every time you call `each`
    query.each do |user|
      pp user.name
    end
    ```

    ## Finding by ID

    ```crystal
    id = 1
    UserQuery.new.find(id)

    # You can also chain methods before calling find, first, etc.
    UserQuery.new.age(30).find(1)
    ```

    ## Ensuring no results are returned

    ```crystal
    UserQuery.new.none
    ```

    This can be helpful when under certain conditions you want the resultd to be empty.

    > This method does not return an empty array immediately. You can still chain other query methods, but it
      will always return no records. For example: `UserQuery.new.none.first` will never return a result

    ## Shorthand methods

    There are a few methods that are used so often that we've added shortcut methods:

    * `find`
    * `first`
    * `last`

    ```crystal
    id = 1
    UserQuery.find(id)
    UserQuery.first
    UserQuery.last
    ```

    ## Type specific query methods

    The previous section mostly focused on simple equality queries, but you can also
    do more advanced queries depending on the column type.

    ### All types

    * `is`
    * `desc_order`
    * `asc_order`

    ### String

    * `like`
    * `ilike`
    * `lower`

    ### Int32 and Time

    * `gt`
    * `gte`
    * `lt`
    * `lte`

    ### Examples

    ```crystal
    UserQuery.new.age.gte(18).name.lower.is("sally")
    ```

    ## Deleting a record

    ```crystal
    user = UserQuery.new.find(id)
    user.delete
    ```

    ## Using scopes

    Generally it's best to name your query methods so they are easy to understand
    and reuse across your app. In Lucky, this is done by extracting methods on the
    query object.

    Here's an example:

    ```crystal
    class UserQuery < User::BaseQuery
      def adults
        age.gte(18)
      end

      def search(name)
        ilike("\#{name}%")
      end
    end

    UserQuery.new.adults.search("Sal")
    ```

    ## Preloading associations

    In development and test environemnts Lucky requries preloading associations.
    If you forget to preload an association, a runtime error will be raised when
    you try to access it. In production, the association will be lazy loaded so
    that users do not see errors.

    This solution means you will find N+1 queries in development and test, and
    users will never see an error in production.

    To preload, just call `preload_{association name}` on the query:

    ```crystal
    PostQuery.new.preload_comments
    ```

    ### Customizing how associations are preloaded

    Sometimes you want to order preloads, or add where clauses. To do this, use
    the `preload_{{ association_name }}` method on the query and pass a query
    object for the association.

    ```crystal
    PostQuery.new.preload_comments(CommentQuery.new.published(true))
    ```

    This is also how you would do nested preloads:

    ```crystal
    # Preload the post's comments, and the comment's author
    PostQuery.new.preload_comments(CommentQuery.new.preload_author)
    ```

    > Note that you can only pass query objects to `preload` if the association
    is defined, otherwise you will get a type error.

    ## Loading associations without preloading

    Sometimes you have a single model and don't need to preload items. Or maybe
    you *can't* preload because the model record is already loaded. In those cases
    you can use the association name with `!`:

    ```crystal
    post = PostQuery.first
    # Returns the associated author and does not trigger a preload error
    post.author!
    ```

    ## Joining and querying associations

    Let's say you have a `Post` model with `has many comments: Comment`, the
    `Comment` model has a `rating` column that is an integer, and the highest rating
    is 5 and lowest is 1.

    If we want to get all posts that have at least 1 highly rated comment, we
    could do something like this:

    ```crystal
    class PostQuery < Post::BaseQuery
      def with_highly_rated_comments
        # Join the comments
        join_comments

        # Get posts with at least one comment with rating greater than or equal to 4
        comments { |comment_query| comment_query.rating.gte(4) }

        # Or do the same thing with the block shorthand syntax
        # See "Short one-argument syntax" in https://crystal-lang.org/docs/syntax_and_semantics/blocks_and_procs.html
        comments(&.rating.gte(4))
      end
    end

    # Or do the same without making a scope method:
    PostQuery.new.join_comments.comments(&.rating.gte(4))
    ```

    These are all the supported join types for associations:

    * `join_{{association_name}}`
    * `inner_join_{{association_name}}`
    * `left_join{{association_name}}`

    So if `Project` `has_many tasks : Task` you'd have `join_tasks`,
    `inner_join_tasks`, etc.

    MD
  end
end
